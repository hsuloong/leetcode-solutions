{"./":{"url":"./","title":"README简介","keywords":"","body":"LeetCode 刷题集 一本记录LeetCode刷题过程的书，分析每个题目，尽量一道题给出多种解题方法。 书结构 截至目前(2020/05/30)，LeetCode总共有1459道算法题，本书每章分为10小节(即10个页面)，每个页面分析8道题，也就是说每章80道题，因此总共需要约19章。 开始吧，少年！ 更新日志 2020/05/31 1.新增1450~1453解题思路 2020/05/30 1.初始化GitBook仓库 2.初始化整本书的结构 Copyright © hsuloong.github.io 2020 all right reserved，powered by Gitbook编辑于： 2020-06-04 00:22:52 "},"chapter-19/":{"url":"chapter-19/","title":"第19章(1441-1520)","keywords":"","body":"第19章 第19章从第1441题至1520题 索引 1450. Number of Students Doing Homework at a Given Time 1451. Rearrange Words in a Sentence 1452. People Whose List of Favorite Companies Is Not a Subset of Another List 1453. Maximum Number of Darts Inside of a Circular Dartboard 1455. Check If a Word Occurs As a Prefix of Any Word in a Sentence 1456. Maximum Number of Vowels in a Substring of Given Length 1457. Pseudo-Palindromic Paths in a Binary Tree Copyright © hsuloong.github.io 2020 all right reserved，powered by Gitbook编辑于： 2020-06-04 00:22:52 "},"chapter-19/leetcode-1449-1456.html":{"url":"chapter-19/leetcode-1449-1456.html","title":"LeetCode第1449至1456题","keywords":"","body":"LeetCode第1449至1456题 1450. Number of Students Doing Homework at a Given Time 1450. Number of Students Doing Homework at a Given Time C++解题源码 原题官方翻译 官方翻译 给你两个整数数组startTime（开始时间）和endTime（结束时间），并指定一个整数queryTime作为查询时间。已知，第i名学生在startTime[i]时开始写作业并于endTime[i]时完成作业。请返回在查询时间queryTime时正在做作业的学生人数。形式上，返回能够使 queryTime处于区间[startTime[i],endTime[i]]（含）的学生人数。 解题思路 暴力求解 题目难度是【简单】，直接做一个O(n)的循环就可以了。对于每对[startTime,endTime]，判断一下queryTime是否在区间内，在的话结果计数器+1。 Hash表计数 采用哈希表计数的前提是startTime、endTime不是很大，而且在给定时间区间的情况下需要用不同的queryTime来查询，否则直接用暴力求解就好了，这是一种典型的多次查询情况下的空间换时间的做法。其建立Hash表的时间复杂度为O(n)*O(avg(endTime-startTime))，空间复杂为O(max(endTime-startTime))，建立完成后，每次查询的时间复杂度为O(1)。 Hash表建立方法为外层循环时间区间对，内层从startTime到endTime循环，C++伪代码如下： // Build Table int hashTable[std::max(endTime)]{0}; for (oneTimePeriod : timePeriods) { for (i = oneTimePeriod.startTime to oneTimePeriod.endTime) { ++hashTable[i]; } } // Query int result = hashTable[queryTime] 1451. Rearrange Words in a Sentence 1451. Rearrange Words in a Sentence C++解题源码 原题官方翻译 官方翻译 「句子」是一个用空格分隔单词的字符串。给你一个满足下述格式的句子text: 句子的首字母大写 text中的每个单词都用单个空格分隔。 请你重新排列text中的单词，使所有单词按其长度的升序排列。如果两个单词的长度相同，则保留其在原句子中的相对顺序。请同样按上述格式返回新的句子。 解题思路 暴力求解 题目难度等级为【中等】，直接先上暴力，先把text分割成单词，可以用std::stringstream或者std::regex来切分，切分后按照题干要求进行排序，使用std::stable_sort算法即可【需要自定义比较函数】，然后把排完序的单词拼接成句子。 1452. People Whose List of Favorite Companies Is Not a Subset of Another List 1452. People Whose List of Favorite Companies Is Not a Subset of Another List C++解题源码 原题官方翻译 官方翻译 给你一个数组favoriteCompanies，其中favoriteCompanies[i]是第i名用户收藏的公司清单（下标从0开始）。 请找出不是其他任何人收藏的公司清单的子集的收藏清单，并返回该清单下标。下标需要按升序排列。 解题思路 暴力求解 最暴力的算法无非是两层循环，对于每个收藏清单判断一下是不是其他收藏清单的子集，但是这样非常容易超时，可以考虑空间换时间。主要有三个优化点： 1.首先在判断是不是子集时，可以预先建好std::map或者std::set，这样可以加速子集判断 2.新建一个保存子集判断结果的数组，形式类似int array[favoriteCompanies.size()][favoriteCompanies.size()]，对于判断完清单1是不是清单2子集后，可以反向判断清单2是不是清单1的子集 3.新建一个是否是其他清单子集的数组，形式类似bool resultArray[favoriteCompanies.size()]，对于命中一个是其他清单子集的清单，内层循环可以直接break 对于第2点，在判断清单1是否为清单2的子集后，清单2是否为清单1的子集有这几种情况 假设清单1的大小为size1，清单2的大小为size2 (1) 清单1是清单2的子集 a)size1 size2，清单2是否为清单1子集情况未知 Bitmap 这是一种典型的空间换时间的策略，先对所有的公司做编号，然后这个公司就可以映射到Bitmap某位上了，这样每个清单都有一个Bitmap，判断是不是子集直接做与操作就好了，比如对于两个清单的Bitmap1和Bitmap2，做与结果与子集关系有如下的情况 1.Bitmap1 & Bitmap2 = Bitmap1，Bitmap1是Bitmap2的子集 2.Bitmap1 & Bitmap2 = Bitmap2，Bitmap2是Bitmap1的子集 3.Bitmap1 & Bitmap2 != Bitmap1 or Bitmap2，两个Bitmap不互为子集 1453. Maximum Number of Darts Inside of a Circular Dartboard 1453. Maximum Number of Darts Inside of a Circular Dartboard C++解题源码 原题官方翻译 官方翻译 墙壁上挂着一个圆形的飞镖靶。现在请你蒙着眼睛向靶上投掷飞镖。投掷到墙上的飞镖用二维平面上的点坐标数组表示。飞镖靶的半径为r。请返回能够落在 任意 半径为r的圆形靶内或靶上的最大飞镖数。 解题思路 暴力求解 双层循环，每两个点计算一次圆心，然后用计算得到的圆心遍历一下所有的点，记录离圆心距离小于半径的点【也就是落在圆内的点】，这个暴力大概率会超时，可以考虑做求圆心的优化。 1.两个点距离超过直径，无法组成圆 2.两个点重合，无法组成圆 对于第1点，可以对点进行排序，每次内层循环点的距离已经超过直径时，内层循环可以直接break Copyright © hsuloong.github.io 2020 all right reserved，powered by Gitbook编辑于： 2020-06-04 00:22:52 "}}